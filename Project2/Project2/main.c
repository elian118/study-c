#include <stdio.h>

main() {

	//short int i = 1; // overflow of signed short int 범위 : -32768 ~ 32767(-2^15 ~ 2^15-1)
	unsigned short int i = 1; // overflow of unsigned short int 범위 : 0 ~ 65535(0 ~ 2^16-1)

	while (i != 0) {
		printf(" %d \n ", i);
		i++;
	}

}

/*
	c언어는 오버플로우가 발생하면 오류발생 없이 자동 순환처리한다.
	자동 순환처리 시 부호를 허용한 경우(signed) 최대값, 부호를 허용하지 않은 경우(unsigned) 0부터 값이 엉망이 된다.

	*오버플로우: 컴퓨터가 표현할 수 있는 수의 범위를 벗어나는 것. c언어에서는 오버플로우를 오류라 판단하지 않고 그저 2진수로 표현할 수 없는 자릿수에 위치한 값을 무시할 뿐이다.
		그래서 값이 어긋나게 된다. 오버플로우가 발생할 수 있는 상황이라면 반드시 개발자가 예외처리를 직접 해주어야 한다.

	*참고

	1. 컴퓨터는 음수를 표현하기 위한 -를 1로 표현하고, 양수를 표현하기 위한 +를 0으로 표현한다.
	2. 순환 처리 시 사람이 예상하는 보수가 보여질 수 있도록, 음수의 경우 원래 컴퓨터가 상정한 값(msb) 순서(-0, -1, -2, -3)와 다르게 역순(-4, -3, -2, -1)으로 보여주게 된다.
	3. 컴퓨터는 오로지 덧셈만 할 줄 안다.
	4. 오버플로우는 하드웨어 성능마다 표현할 수 있는 숫자 범위가 다르므로 제각각일 수 있으나, C는 자료형을 표준화해서 하드웨어에 상관없이 동일하게 동작하도록 한다.
	5. 오버플로우 방지를 위해 되도록 큰 자료형을 사용하는 게 좋지만, 이는 애초부터 메모리를 그만큼 많이 잡아먹는다는 단점이 있다.
		* 자료형의 크기 순서(오버플로우 발생 가능 범위 순서)
			long long int(8byte) > unsigned long long int(8byte) >
				long float(8byte) > double(8byte) > long long int(8byte) > float(4byte) > unsigned long int(4byte) > int(4byte) > short int(2byte) > char(1byte)
	6. 부동소수점은 정수부와 소수부를 나누어 표현하는 방식이므로, 오버플로우가 발생할 수 있는 범위가 훨씬 더 크다.
		

	규칙
		 보수(compliment): 9의 7에 대한 보수 는 2

	un signed   msb     signed
	0   	    0 00    +0
	1   	    0 01    +1
	2   	    0 10    +2
	3   	    0 11    +3         + max

	4   	    1 00    -0   -4    - max
	5   	    1 01    -1   -3
	6   	    1 10    -2   -2
	7  max      1 11    -3   -1  <- 가장 마지막 숫자
			   10 00
	덧셈 -> 뺄셈 (+2) + (-3) ==  2 - 3
*/